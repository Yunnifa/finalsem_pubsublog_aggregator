UAS Sistem Terdistribusi (Take-Home, 1 Minggu)
Tema: Pub-Sub Log Aggregator Terdistribusi dengan Idempotent Consumer, Deduplication, dan Transaksi/Kontrol Konkurensi (Docker Compose Wajib)

Deskripsi Singkat:
Bangun sistem Pub-Sub log aggregator multi-service yang berjalan dengan Docker Compose. Sistem harus mendukung idempotency (consumer tidak memproses ulang event yang sama), deduplication kuat, serta transaksi/konkurensi yang mencegah race condition dan memastikan konsistensi data. Semua layanan berjalan pada jaringan lokal Compose, tanpa akses layanan eksternal publik.

catatan: contoh penggunaan K6 github 

Ketentuan Umum:

Individu, take-home 1 minggu.
Bahasa: Indonesia dengan istilah teknis Inggris bila relevan.
Cakupan teori: Bab 1–13 dari buku utama (docs/buku-utama.pdf). Penekanan pada Transactions/Concurrency Control.
Bahasa pemrograman: Rust atau Python (pilih salah satu).
Docker Compose: Wajib. Boleh menggunakan image open-source tambahan sebagai internal service (mis. redis, nats, postgres).
Jaringan: hanya lokal dalam Compose (tanpa akses ke layanan eksternal publik).
Persistensi data: harus aman meski container dihapus (gunakan named volumes/bind mounts).
Video demo: wajib (YouTube unlisted atau public), durasi maksimal 25 menit.
Unit/Integration Tests: tingkatkan menjadi 12–20 tests.
Submit via link GitHub + laporan PDF atau MD (APA 7th – Bahasa Indonesia untuk sitasi).
Tujuan Pembelajaran (Bab 1–13):

Bab 1–2: Karakteristik sistem terdistribusi dan arsitektur (publish–subscribe, microservices).
Bab 3–4: Komunikasi antar komponen dan penamaan (topic, event_id).
Bab 5: Waktu dan ordering (logical/monotonic ordering, toleransi event out-of-order).
Bab 6: Toleransi kegagalan (duplikasi, crash, retry, backoff, graceful restart).
Bab 7: Konsistensi dan replikasi (eventual/causal; idempotency + dedup untuk konsistensi).
Bab 8–9: Transaksi dan kontrol konkurensi (ACID, isolation, conflict resolution, idempotent upsert).
Bab 10–11: Keamanan dan sistem berkas/penyimpanan terdistribusi (akses lokal, isolasi jaringan Compose, persistensi).
Bab 12–13: Sistem berbasis web dan koordinasi (orchestration, observability, readiness/liveness, koordinasi antar service).

Struktur Tugas

Bagian Teori (30%)
Jawab ringkas (150–250 kata/poin) dan sertakan sitasi APA 7th. Soroti Bab 8–9 (transaksi/konkurensi) disertai contoh dari rancangan Anda.

T1 (Bab 1): Karakteristik sistem terdistribusi dan trade-off desain Pub-Sub aggregator.
T2 (Bab 2): Kapan memilih arsitektur publish–subscribe dibanding client–server? Alasan teknis.
T3 (Bab 3): At-least-once vs exactly-once delivery; peran idempotent consumer.
T4 (Bab 4): Skema penamaan topic dan event_id (unik, collision-resistant) untuk dedup.
T5 (Bab 5): Ordering praktis (timestamp + monotonic counter); batasan dan dampaknya.
T6 (Bab 6): Failure modes dan mitigasi (retry, backoff, durable dedup store, crash recovery).
T7 (Bab 7): Eventual consistency pada aggregator; peran idempotency + dedup.
T8 (Bab 8): Desain transaksi: ACID, isolation level, dan strategi menghindari lost-update.
T9 (Bab 9): Kontrol konkurensi: locking/unique constraints/upsert; idempotent write pattern.
T10 (Bab 10–13): Orkestrasi Compose, keamanan jaringan lokal, persistensi (volume), observability.
Bagian Implementasi (70%)
Bangun sistem multi-service dengan Docker Compose (wajib) dan pilihan bahasa Python atau Rust.
a. Arsitektur Layanan (Compose)

aggregator: API untuk publish dan akses event; consumer internal memproses queue.
publisher: generator/simulator event (termasuk duplikasi) ke broker/aggregator.
broker (opsional namun disarankan): message broker internal (mis. redis, nats).
storage: database persisten (mis. postgres:16-alpine) atau file-based (SQLite) dengan volume.
Jaringan Compose: default network internal; tidak ada port keluar ke layanan eksternal selain expose untuk demo lokal.
b. Model Event & API

Event JSON minimal: { "topic": "string", "event_id": "string-unik", "timestamp": "ISO8601", "source": "string", "payload": { ... } }.
Endpoint POST /publish: menerima single/batch event; validasi skema.
Endpoint GET /events?topic=...: daftar event unik yang telah diproses.
Endpoint GET /stats: received, unique_processed, duplicate_dropped, topics, uptime.
c. Idempotency & Deduplication (Persisten)

Dedup store persisten (Postgres: tabel dengan constraint unik (topic, event_id); atau SQLite dengan file di volume).
Idempotency: event (topic, event_id) yang sama hanya diproses sekali walau diterima berkali-kali.
Logging jelas untuk deteksi duplikasi; audit log disarankan.
d. Transaksi & Konkurensi

Terapkan transaksi saat insert/processing untuk mencegah race condition.
Gunakan upsert/unique constraints untuk dedup atomik (contoh: INSERT ... ON CONFLICT DO NOTHING).
Uji konkurensi: jalankan beberapa worker/threads consumer; buktikan tidak ada double-process.
Jelaskan isolation level yang dipilih (mis. READ COMMITTED atau SERIALIZABLE) dan alasan.
Contoh Kasus Transaksi (Disarankan)

Dedup berbasis constraint unik (wajib): saat memproses event (topic, event_id), lakukan insert ke tabel processed_events dengan constraint unik (topic, event_id) di dalam satu transaksi. Jika konflik, abaikan (idempotent). Bukti: dua worker paralel tidak menghasilkan duplicate processing.
Outbox + upsert (opsional): saat aggregator menyimpan event, tulis juga ke tabel outbox dalam transaksi yang sama, lalu proses outbox secara terpisah. Pastikan setiap item outbox diproses sekali (gunakan marker/versi atau delete dengan transaksi). Bukti: tidak ada side-effect ganda.
Batch atomic (opsional): POST /publish menerima batch; seluruh batch berhasil atau gagal atomik (transaction boundary). Alternatif: partial commit yang tetap idempotent (jelaskan kebijakan). Bukti: integrity terjaga meski ada item invalid.
Konsistensi statistik (opsional): update received, unique_processed, duplicate_dropped secara transaksional agar bebas lost-update saat multi-worker (contoh SQL UPDATE ... SET count = count + 1 WHERE ...). Bukti: angka konsisten di bawah beban.
Isolation level (wajib dijelaskan): pilih isolation (READ COMMITTED/SERIALIZABLE) sesuai kebutuhan; jelaskan trade-off (phantom reads, write skew) dan mitigasi (unique constraints, upsert, retry).
e. Reliability & Ordering

At-least-once delivery: publisher mengirim duplikat; sistem tetap konsisten.
Crash tolerance: setelah restart (atau container recreate), dedup store mencegah reprocessing.
Ordering: jelaskan apakah total ordering diperlukan; sediakan strategi praktis.
f. Performa Minimum

Proses ≥ 20.000 event (≥ 30% duplikasi) tetap responsif.
Sertakan metrik throughput/latency/duplicate rate di laporan.
g. Docker & Compose (Wajib)

Sediakan Dockerfile untuk layanan aplikasi (aggregator/publisher) dan docker-compose.yml.
Rekomendasi Python: base python:3.11-slim, non-root user, requirements.txt.
Rekomendasi Rust: base rust:1.72-slim (build), runtime image minimal (mis. debian:bookworm-slim).
Persistensi: gunakan named volumes/bind mounts untuk database/file store; dokumentasikan lokasi data.
Contoh skeleton docker-compose.yml (sesuaikan stack pilihan):
services:
  aggregator:
    build: ./aggregator
    image: uts-aggregator:latest
    depends_on: [storage, broker]
    environment:
      - DATABASE_URL=postgres://user:pass@storage:5432/db
      - BROKER_URL=redis://broker:6379
    ports:
      - "8080:8080"
    volumes:
      - aggregator_data:/var/lib/aggregator  # jika memakai file-based store

  publisher:
    build: ./publisher
    image: uts-publisher:latest
    depends_on: [broker]
    environment:
      - TARGET_URL=http://aggregator:8080/publish

  broker:
    image: redis:7-alpine
    ports: []  # tetap internal
    volumes:
      - broker_data:/data

  storage:
    image: postgres:16-alpine
    environment:
      - POSTGRES_DB=db
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=pass
    volumes:
      - pg_data:/var/lib/postgresql/data

volumes:
  pg_data:
  broker_data:
  aggregator_data:
h. Unit/Integration Tests (12–20 tests)

Gunakan pytest/unittest (Python) atau framework Rust (tokio, assert_cmd, dsb.).
Cakupan minimum:
Dedup: kirim duplikat → hanya sekali diproses.
Persistensi: setelah container recreate, dedup tetap mencegah reprocessing.
Transaksi/konkurensi: multi-worker menghasilkan data konsisten (uji race conditions).
Validasi skema event.
GET /stats dan GET /events konsisten.
Stress kecil: batch event dan ukur waktu eksekusi.
(Opsional) Integration test terhadap service Compose (mis. test container).
Video Demo (Wajib, ≤ 25 menit, YouTube unlisted/public)

Cantumkan link di README.md atau laporan.
Tampilkan semua poin yang dinilai pada rubrik (wajib dipresentasikan), minimal mencakup:
Arsitektur multi-service dan alasan desain.
Proses build image dan menjalankan Compose (docker compose up).
Pengiriman event duplikat dan bukti idempotency + dedup.
Demonstrasi transaksi/konkurensi (multi-worker) dan hasil konsisten.
GET /events dan GET /stats sebelum/sesudah.
Crash/recreate container + bukti data persisten via volumes.
Keamanan jaringan lokal (tidak ada dependensi eksternal).
Observability (logging, metrik), serta ringkasan keputusan desain.
Deliverables (GitHub + Laporan)

Repository GitHub berisi:
aggregator/ dan publisher/ (kode aplikasi) + Dockerfile masing-masing.
docker-compose.yml (wajib).
tests/ (12–20 tests) dan cara menjalankan.
README.md (build/run, arsitektur, endpoints, asumsi, cara test).
report.md atau report.pdf (Bab 1–13, penekanan Bab 8–9, metrik, keputusan desain).
Link video demo (YouTube unlisted/public).
Instruksi run singkat:
Compose up: docker compose up --build
Akses aggregator: http://localhost:8080
Format Laporan (MD/PDF)

Ringkasan sistem dan arsitektur.
Keputusan desain: idempotency, dedup store, transaksi/konkurensi, ordering, retry.
Analisis performa/metrik; hasil uji konkurensi.
Keterkaitan ke Bab 1–13 (cantumkan referensi per bagian).
Sitasi buku utama: APA edisi ke-7 (Bahasa Indonesia).
Format buku: Nama Belakang, Inisial. (Tahun). Judul buku: Subjudul jika ada. Penerbit.
Contoh sitasi dalam teks: (Nama Belakang, Tahun).
Sesuaikan metadata dengan docs/buku-utama.pdf.
Rubrik Penilaian (Total 100)

Teori (30 poin)
T1–T10: kedalaman, akurasi, sitasi tepat (3 poin x 10 = 30).
Implementasi (70 poin)
Arsitektur & Correctness (12): memenuhi spesifikasi API dan perilaku multi-service.
Idempotency & Dedup (12): dedup akurat, tahan restart, logging jelas.
Transaksi & Konkurensi (16): isolation/locking/upsert benar, bebas race, bukti uji.
Dockerfile & Compose (10): image minimal, Compose berjalan mulus, jaringan lokal.
Persistensi (8): data aman meski container dihapus; dokumentasi volume.
Tests (7): 12–20 tests, cakupan inti, cara menjalankan jelas.
Observability & Dokumentasi (5): GET /stats, logging/metrik, README/laporan jelas.
Catatan: Semua item implementasi di atas wajib ditunjukkan dalam video demo.
Kebijakan & Tenggat

Durasi: 1 minggu sejak pembagian. Keterlambatan mengikuti kebijakan kelas (mis. -10%/hari).
Individual work: cantumkan sumber; hindari plagiarisme.
Saran Teknis

Python: FastAPI + asyncio, Redis/NATS untuk broker; Postgres/SQLite + volume.
Rust: axum/actix-web, tokio untuk async; dedup dengan Postgres/SQLite + volume.
Gunakan upsert/unique constraints; pertimbangkan retry dengan backoff.
Optionally gunakan readiness/liveness untuk health check service.
Catatan Penting

Tidak menggunakan layanan eksternal publik; semua internal Compose.
Pastikan bukti persisten: hapus/recreate container lalu tunjukkan data tetap ada (named volumes).